---
phase: 08-verify-and-fix
plan: 02
type: execute
wave: 2
depends_on: [08-01]
files_modified: []
autonomous: false
requirements: [VERIFY-01, VERIFY-02, VERIFY-03, VERIFY-04]

must_haves:
  truths:
    - "管理員勾選登入按鈕位置後儲存，重載頁面後勾選狀態保留"
    - "修改設定值後立即重載，新值立即反映（不需等 1 小時）"
    - "使用 curl 呼叫 /messages/text 帶有效 API Key，回傳 success:true"
    - "5 個 Hook 可正常呼叫不報錯"
    - "API Key 修復後（hash_equals）舊 Key 仍可驗證"
    - "broadcast 超過 100 user_ids 回傳 HTTP 400"
  artifacts: []
  key_links:
    - from: "curl POST /line-hub/v1/messages/text"
      to: "LINE API push"
      via: "PublicAPI → MessagingService → LINE API"
      pattern: "success.*true"
    - from: "SettingsPage save_login_tab"
      to: "SettingsService get(login_button_positions)"
      via: "set() → clear_cache() → get() 從 DB 讀取"
      pattern: "login_button_positions"
---

<objective>
在 test.buygo.me 環境中端到端驗證所有 Phase 8 修復項目和既有功能

Purpose: 確認 08-01 修復正確、既有功能（設定存取、Hook、REST API）全部可用
Output: 驗證報告，確認所有 VERIFY-01~05 通過
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-verify-and-fix/08-RESEARCH.md
@.planning/phases/08-verify-and-fix/08-01-SUMMARY.md

# 修復後的原始碼
@includes/api/class-public-api.php
@includes/services/class-integration-hooks.php
@includes/admin/class-users-column.php
@includes/services/class-settings-service.php
@includes/admin/class-settings-page.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: 設定系統驗證 + REST API 端到端測試</name>
  <files>無檔案修改 — 此任務僅執行測試並記錄結果到 SUMMARY</files>
  <action>
在 test.buygo.me 環境中執行以下驗證，使用 Playwright 瀏覽器和 curl 指令。

**重要：此任務的目標是「記錄所有測試結果」，不論 PASS 或 FAIL 都不阻塞後續。** 測試失敗不代表任務失敗 — 任務完成標準是「所有測試項目都已執行並記錄結果」。

**VERIFY-01：SettingsService array 序列化驗證**

1. 使用 Playwright 登入 https://test.buygo.me/wp-admin/（帳號 facemarketin@gmail.com / nms149149）
2. 進入 LINE Hub 設定頁 > 登入 Tab
3. 勾選所有登入按鈕位置（wp_login、fluentcart_checkout 等）
4. 點擊儲存
5. 重新載入頁面
6. 確認勾選狀態是否保留

如果勾選狀態丟失，記錄以下診斷資訊：
- 用 curl 或 WP-CLI 查詢 `line_hub_settings` 資料表中 `setting_group='general'` AND `setting_key='login_button_positions'` 的值
- 檢查值是否為有效 JSON array（如 `["wp_login","fluentcart_checkout"]`）
- 記錄實際的值格式，供 Task 2 checkpoint 決定是否需要修復

**VERIFY-02：Transient 快取清除驗證**

1. 在登入 Tab 修改「登入按鈕文字」為一個辨識度高的值（如「Phase8 測試按鈕」）
2. 儲存
3. 立即重新載入頁面
4. 確認新文字立即顯示（不是舊值）
5. 如果仍顯示舊值，記錄 transient 快取狀態（`wp transient get line_hub_setting_general_login_button_text`）

**VERIFY-03：REST API 端點測試**

前置：確認 LINE Hub 有有效的 API Key。如果沒有，先在開發者 Tab 生成一個。

測試 5 個 REST API 端點（用 curl）：

```bash
# 取得 API Key（需要先在後台生成或從 DB 查詢）
API_KEY="lhk_xxxxx"  # 替換為實際 key

# 1. POST /messages/text
curl -s -X POST https://test.buygo.me/wp-json/line-hub/v1/messages/text \
  -H "X-LineHub-API-Key: $API_KEY" \
  -H "Content-Type: application/json" \
  -d '{"user_id": 1, "message": "Phase 8 驗證測試"}'
# 預期：{"success":true,"message":"訊息已發送"} 或 user 未綁定的錯誤

# 2. POST /messages/flex
curl -s -X POST https://test.buygo.me/wp-json/line-hub/v1/messages/flex \
  -H "X-LineHub-API-Key: $API_KEY" \
  -H "Content-Type: application/json" \
  -d '{"user_id": 1, "alt_text": "測試", "contents": {"type": "bubble", "body": {"type": "box", "layout": "vertical", "contents": [{"type": "text", "text": "Phase 8 Flex 測試"}]}}}'

# 3. POST /messages/broadcast（正常請求，< 100 人）
curl -s -X POST https://test.buygo.me/wp-json/line-hub/v1/messages/broadcast \
  -H "X-LineHub-API-Key: $API_KEY" \
  -H "Content-Type: application/json" \
  -d '{"user_ids": [1], "message": "Phase 8 broadcast 測試"}'

# 4. GET /users/{id}/binding
curl -s https://test.buygo.me/wp-json/line-hub/v1/users/1/binding \
  -H "X-LineHub-API-Key: $API_KEY"
# 預期：{"success":true,"user_id":1,"is_linked":true/false,...}

# 5. GET /users/lookup
curl -s "https://test.buygo.me/wp-json/line-hub/v1/users/lookup?email=facemarketin@gmail.com" \
  -H "X-LineHub-API-Key: $API_KEY"
# 預期：{"success":true,"user_id":...,"is_linked":...}
```

**VERIFY-04：hash_equals 向後相容測試**

使用上面相同的 API Key 進行認證測試（如果上述 curl 測試通過，即表示 hash_equals 向後相容）。

**VERIFY-05：broadcast 100 人上限測試**

```bash
# 生成 101 個 user_ids 的 JSON
USER_IDS=$(python3 -c "import json; print(json.dumps(list(range(1, 102))))")

curl -s -X POST https://test.buygo.me/wp-json/line-hub/v1/messages/broadcast \
  -H "X-LineHub-API-Key: $API_KEY" \
  -H "Content-Type: application/json" \
  -d "{\"user_ids\": $USER_IDS, \"message\": \"超限測試\"}"
# 預期：HTTP 400，{"success":false,"message":"user_ids 數量超過上限（最多 100 個）"}
```

**VERIFY-03（補充）：Hook 驗證**

透過 WordPress 後台或 curl 執行 PHP 程式碼來觸發 Hook：

```bash
# Filter 驗證（不需要 LINE API）
curl -s "https://test.buygo.me/wp-json/line-hub/v1/users/1/binding" \
  -H "X-LineHub-API-Key: $API_KEY"
# 這實際上是在內部呼叫 UserService::isLinked() 和 getLineUid()
# 如果回應中有 is_linked 和 line_uid 欄位，表示 Filter 的底層邏輯正常

# Action Hook 的驗證已被 REST API /messages/text 測試涵蓋
# 因為 REST API 和 Hook 共用相同的 MessagingService
```

**記錄所有測試結果**到 SUMMARY 中，格式：
- VERIFY-01: PASS/FAIL + 說明
- VERIFY-02: PASS/FAIL + 說明
- VERIFY-03: PASS/FAIL + 說明（每個端點分別記錄）
- VERIFY-04: PASS/FAIL + 說明
- VERIFY-05: PASS/FAIL + 說明
  </action>
  <verify>
    <automated>curl -s -o /dev/null -w "%{http_code}" https://test.buygo.me/wp-json/line-hub/v1/messages/broadcast -X POST -H "Content-Type: application/json" -d '{"user_ids": [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101], "message": "test"}'</automated>
    <manual>確認回傳 HTTP 401（沒有 API Key）或 400（有 API Key 時超限拒絕）</manual>
  </verify>
  <done>所有 5 個 VERIFY 項目已執行測試並記錄結果（不論 PASS/FAIL），驗證報告完整</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: 用戶確認驗證結果並決定是否需追加修復</name>
  <what-built>
Phase 8 所有修復和驗證已完成：
1. VERIFY-01：SettingsService array 序列化（登入按鈕位置勾選保留）
2. VERIFY-02：Transient 快取清除（設定值立即反映）
3. VERIFY-03：5 個 Hook + 5 個 REST API 端點端到端測試
4. VERIFY-04：hash_equals 認證向後相容
5. VERIFY-05：broadcast 100 人上限

所有測試結果記錄在 Task 1 的驗證報告中。
  </what-built>
  <how-to-verify>
1. 檢查驗證報告中的每個 VERIFY 項目是否全部 PASS
2. 可選：自行在 test.buygo.me 後台操作驗證
   - 進入 LINE Hub > 登入 Tab，勾選按鈕位置 → 儲存 → 重載 → 確認保留
   - 進入 LINE Hub > 開發者 Tab，確認 API Key 仍可使用
3. **如果 VERIFY-01 或 VERIFY-02 失敗，以下是修復指引：**

**VERIFY-01 失敗時的修復路徑（array 序列化問題）：**
根據 RESEARCH.md 分析，最可能的原因是快取殘留（不是序列化邏輯錯誤）。修復步驟：
- 檢查 `line_hub_settings` 資料表中的實際值格式
- 如果 DB 值正確但頁面顯示錯誤 → 問題在 transient 快取，清除所有 `line_hub_setting_*` transient
- 如果 DB 值格式錯誤（例如 PHP serialize 而非 JSON） → 修復 `SettingsService::set()` 中的 `json_encode` 邏輯
- 如果 `cast_value()` 對 JSON 字串的 `json_decode` 返回 null → 檢查 JSON 格式是否有 escape 問題

**VERIFY-02 失敗時的修復路徑（Transient 快取未清除）：**
根據 RESEARCH.md 分析，`set()` 方法在 `$wpdb->replace()` 返回 truthy 後才呼叫 `clear_cache()`。修復步驟：
- 確認 `$wpdb->replace()` 的實際返回值（用 `error_log` 記錄）
- 如果返回值為 0 或 false 導致 `clear_cache()` 未被呼叫 → 修改條件為 `if ($result !== false)`
- 如果 `clear_cache()` 有被呼叫但 transient 仍存在 → 檢查是否有 object cache plugin（如 Redis）覆蓋了 `delete_transient` 行為

4. 如果所有 VERIFY 都 PASS → 直接 approve
5. 如果有 FAIL → 描述失敗項目，將啟動追加修復 Plan（08-03）
  </how-to-verify>
  <resume-signal>輸入 "approved" 確認所有驗證通過，或描述需要修正的問題（將啟動追加修復計畫）</resume-signal>
</task>

</tasks>

<verification>
Phase 8 完成驗證清單：

1. [ ] VERIFY-01：登入按鈕位置勾選 → 儲存 → 重載 → 勾選保留
2. [ ] VERIFY-02：修改設定值 → 儲存 → 立即重載 → 新值顯示
3. [ ] VERIFY-03：5 個 REST API 端點回傳預期結果
4. [ ] VERIFY-03：Hook 底層邏輯（UserService）查詢正常
5. [ ] VERIFY-04：舊 API Key 在 hash_equals 修復後仍可驗證
6. [ ] VERIFY-05：101 個 user_ids 的 broadcast 回傳 HTTP 400
</verification>

<success_criteria>
- 所有 5 個 VERIFY 項目全部 PASS
- 驗證報告記錄完整
- 用戶確認驗證結果
</success_criteria>

<output>
完成後建立 `.planning/phases/08-verify-and-fix/08-02-SUMMARY.md`
</output>
