---
phase: 03-oauth-authentication
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - includes/auth/class-oauth-state.php
  - includes/auth/class-oauth-client.php
autonomous: true
user_setup: []

must_haves:
  truths:
    - "State 參數使用加密安全隨機產生（random_bytes）"
    - "State 有 5 分鐘過期時間"
    - "匿名用戶和登入用戶都能正確儲存 State"
    - "OAuthClient 可以產生 LINE 授權 URL"
    - "OAuthClient 可以交換 code 取得 tokens"
    - "OAuthClient 可以驗證 ID Token 並取得 email"
  artifacts:
    - path: "includes/auth/class-oauth-state.php"
      provides: "OAuth State 產生、驗證、儲存（NSL 模式）"
      min_lines: 80
    - path: "includes/auth/class-oauth-client.php"
      provides: "LINE OAuth 2.0 客戶端"
      min_lines: 120
  key_links:
    - from: "includes/auth/class-oauth-state.php"
      to: "WordPress Transient API"
      via: "set_transient / get_transient"
      pattern: "set_transient.*line_hub"
    - from: "includes/auth/class-oauth-client.php"
      to: "LINE API"
      via: "wp_remote_post / wp_remote_get"
      pattern: "wp_remote_(post|get).*line\\.me"
---

<objective>
建立 OAuth 核心基礎設施：State 管理和 LINE OAuth Client

Purpose: 提供安全的 CSRF 防護（State 參數）和 LINE API 通訊能力，為後續認證流程打基礎
Output: OAuthState 類別（State 產生/驗證）和 OAuthClient 類別（LINE API 通訊）
</objective>

<execution_context>
@/Users/fishtv/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fishtv/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-oauth-authentication/03-RESEARCH.md

# Phase 2 提供的基礎
@includes/services/class-user-service.php
@includes/services/class-settings-service.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: 建立 OAuthState 類別</name>
  <files>includes/auth/class-oauth-state.php</files>
  <action>
建立 `LineHub\Auth\OAuthState` 靜態類別，實作 NSL 的 State 儲存模式：

**常數定義：**
- `STATE_LENGTH = 32` - State 字串長度
- `EXPIRATION_SECONDS = 300` - 5 分鐘過期（用戶決策）

**公開方法：**

1. `generate(): string`
   - 產生加密安全隨機 State（使用 random_bytes + bin2hex）
   - 同時儲存 State 到 Transient
   - 根據用戶登入狀態選擇儲存方式：
     - 登入用戶：`set_transient('line_hub_state_' . get_current_user_id(), $state, 300)`
     - 匿名用戶：使用 session-based 儲存（cookie + site_transient）
   - 返回 State 字串

2. `validate(string $received_state): bool`
   - 取得儲存的 State
   - 使用 `hash_equals()` 進行時序安全比較
   - 驗證後立即刪除 State（防止重用）
   - 返回驗證結果

3. `storeRedirect(string $url): void`
   - 儲存原始頁面 URL 用於登入後重定向
   - 使用相同的 Transient 機制

4. `getRedirect(): ?string`
   - 取得儲存的重定向 URL
   - 取得後刪除（一次性使用）
   - 驗證 URL 安全性（wp_validate_redirect）

**私有方法：**

5. `getOrCreateSessionId(): string`
   - 檢查 `line_hub_session` cookie
   - 如果不存在，建立新的唯一 ID 並設置 cookie
   - 返回 hash 後的 session ID（用於 Transient key）
   - 參考 NSL Session.php 模式

6. `getStoredState(): ?string`
   - 根據登入狀態從對應 Transient 取得 State

7. `deleteState(): void`
   - 刪除已使用的 State

**安全要點：**
- 使用 `random_bytes()` 而非 `rand()` 或 `mt_rand()`
- cookie 設置使用 `COOKIEPATH`, `COOKIE_DOMAIN`, `is_ssl()`
- Transient key 使用 `SECURE_AUTH_KEY` 加 hash
  </action>
  <verify>
檢查檔案存在且包含所有方法：
```bash
grep -E "(function generate|function validate|function storeRedirect|function getRedirect)" includes/auth/class-oauth-state.php
```
  </verify>
  <done>
OAuthState 類別完成，包含 State 產生、驗證、重定向儲存功能，使用 5 分鐘過期時間
  </done>
</task>

<task type="auto">
  <name>Task 2: 建立 OAuthClient 類別</name>
  <files>includes/auth/class-oauth-client.php</files>
  <action>
建立 `LineHub\Auth\OAuthClient` 類別，封裝 LINE OAuth 2.0 API 通訊：

**常數定義：**
```php
private const AUTH_ENDPOINT = 'https://access.line.me/oauth2/v2.1/authorize';
private const TOKEN_ENDPOINT = 'https://api.line.me/oauth2/v2.1/token';
private const VERIFY_ENDPOINT = 'https://api.line.me/oauth2/v2.1/verify';
private const PROFILE_ENDPOINT = 'https://api.line.me/v2/profile';
```

**建構函式：**
從 SettingsService 取得 LINE Login 設定（channel_id, channel_secret），並計算 redirect_uri

**公開方法：**

1. `createAuthUrl(array $options = []): string`
   - 呼叫 OAuthState::generate() 取得 State
   - 組裝授權 URL，參數包含：
     - response_type: code
     - client_id: 從設定取得
     - redirect_uri: callback URL
     - state: 產生的 State
     - scope: 'profile openid email'
   - 可選參數（AUTH-08）：
     - bot_prompt: 從 $options 或設定取得
     - initial_amr_display: QR code 登入選項
     - disable_auto_login: true（強制手動登入）
     - disable_ios_auto_login: true
   - 返回完整授權 URL

2. `createReauthUrl(): string`
   - 建立強制重新授權 URL（AUTH-03）
   - 與 createAuthUrl 相同，但加入 `prompt=consent` 參數
   - 用於用戶需要重新授權 Email 權限時

3. `authenticate(string $code): array`
   - 使用 wp_remote_post 發送 token 請求
   - 參數：grant_type, code, redirect_uri, client_id, client_secret
   - 處理錯誤回應，拋出 Exception
   - 返回 tokens 陣列（access_token, id_token, refresh_token）

4. `verifyIdToken(string $id_token): array`
   - 使用 LINE verify endpoint 驗證 ID Token
   - 傳送 id_token 和 client_id
   - 返回驗證結果（包含 email 如果有的話）
   - 失敗返回空陣列

5. `getProfile(string $access_token): array`
   - 使用 Bearer token 呼叫 profile API
   - 返回用戶資料（userId, displayName, pictureUrl）

**私有方法：**

6. `getRedirectUri(): string`
   - 返回 callback URL：`home_url('/line-hub/auth/callback')`

**錯誤處理：**
- wp_remote_* 錯誤時拋出 Exception
- HTTP 非 200 回應時拋出 Exception 含錯誤描述
- 使用 `wp_remote_retrieve_response_code()` 檢查狀態碼
- 使用 `is_wp_error()` 檢查 wp_remote_* 回傳值
  </action>
  <verify>
檢查 LINE API endpoints、核心方法和 HTTP 通訊：
```bash
grep -E "(AUTH_ENDPOINT|TOKEN_ENDPOINT|createAuthUrl|createReauthUrl|authenticate|verifyIdToken|getProfile|wp_remote_post|wp_remote_get|is_wp_error)" includes/auth/class-oauth-client.php
```
  </verify>
  <done>
OAuthClient 類別完成，可產生授權 URL（含強制重新授權）、交換 token、驗證 ID Token、取得用戶資料，並有完整的 HTTP 錯誤處理
  </done>
</task>

</tasks>

<verification>
## 程式碼驗證

1. **OAuthState 安全性檢查：**
   - 確認使用 random_bytes 而非弱隨機
   - 確認使用 hash_equals 而非 == 比較
   - 確認 State 驗證後立即刪除

2. **OAuthClient API 呼叫檢查：**
   - 確認使用 wp_remote_post/get 而非 cURL
   - 確認有適當的超時設定（15 秒）
   - 確認錯誤處理完整（is_wp_error + response_code 檢查）

3. **命名空間和自動載入：**
   - 確認 namespace 為 LineHub\Auth
   - 確認檔案路徑符合 PSR-4 命名規則
</verification>

<success_criteria>
1. OAuthState::generate() 產生 64 字元 hex 字串
2. OAuthState::validate() 正確比較並刪除 State
3. OAuthClient::createAuthUrl() 產生包含所有必要參數的 LINE 授權 URL
4. OAuthClient::createReauthUrl() 產生包含 prompt=consent 的強制重新授權 URL
5. OAuthClient 的 authenticate/verifyIdToken/getProfile 方法有完整的錯誤處理
6. 兩個類別的 namespace 正確，可被自動載入
</success_criteria>

<output>
完成後建立 `.planning/phases/03-oauth-authentication/03-01-SUMMARY.md`
</output>
