---
phase: 11-安全補齊與常數統一
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - includes/liff/class-liff-handler.php
  - includes/auth/class-auth-callback.php
autonomous: true
requirements:
  - SEC-10

must_haves:
  truths:
    - "在 LIFF 登入 redirect 參數中注入外部網址（如 redirect=https://evil.com），系統拒絕跳轉並導回首頁"
    - "在 OAuth callback 的 redirect 參數中注入外部網址，系統拒絕跳轉並導回首頁"
    - "所有 $_GET/$_POST 的 redirect 參數經過 wp_validate_redirect 驗證"
    - "LINE 登入完整流程（LIFF 和 OAuth）在修正後正常運作"
  artifacts:
    - path: "includes/liff/class-liff-handler.php"
      provides: "LIFF redirect 安全驗證"
      contains: "wp_validate_redirect"
    - path: "includes/auth/class-auth-callback.php"
      provides: "OAuth redirect 安全驗證"
      contains: "wp_validate_redirect"
  key_links:
    - from: "includes/liff/class-liff-handler.php::resolveRedirectUrl"
      to: "wp_validate_redirect"
      via: "Open Redirect 防護"
      pattern: "wp_validate_redirect"
    - from: "includes/auth/class-auth-callback.php::initiateAuth"
      to: "wp_validate_redirect"
      via: "Open Redirect 防護"
      pattern: "wp_validate_redirect"
---

<objective>
修正所有 redirect 參數的 Open Redirect 漏洞，確保所有用戶輸入經過適當 sanitize

Purpose: 防止攻擊者透過 redirect 參數將用戶導向惡意外部網站（Open Redirect），這是 OWASP Top 10 安全風險之一
Output: 修正後的 class-liff-handler.php 和 class-auth-callback.php
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@includes/liff/class-liff-handler.php
@includes/auth/class-auth-callback.php
@includes/auth/class-oauth-state.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: 修正 LIFF Handler 的 Open Redirect 漏洞</name>
  <files>includes/liff/class-liff-handler.php</files>
  <action>
修正 `class-liff-handler.php` 中的 redirect 安全問題：

**1. 修正 `resolveRedirectUrl()` 方法（第 634 行附近）**

目前問題：此方法只用 `esc_url_raw()` 處理 URL，這僅做 URL 格式化（移除不安全字元），但**不會阻擋外部網址**。攻擊者可以傳入 `redirect=https://evil.com` 並通過驗證。

修正：將 `esc_url_raw()` 替換為 `wp_validate_redirect()`，限制重定向只能到本站網址：

```php
private function resolveRedirectUrl(string $redirect): string {
    $redirect = trim($redirect);

    if (empty($redirect)) {
        return home_url('/');
    }

    // 相對路徑轉絕對 URL
    if (strpos($redirect, 'http') !== 0) {
        $redirect = home_url($redirect);
    }

    // 使用 wp_validate_redirect 防止 Open Redirect — 只允許本站 URL
    return wp_validate_redirect($redirect, home_url('/'));
}
```

**2. 修正 GET redirect 參數的 sanitize（第 96 行附近）**

目前問題：`$_GET['redirect']` 只做了 `wp_unslash()` 沒有 sanitize。
修正：加入 `sanitize_text_field()`：

```php
$redirect = isset($_GET['redirect']) ? sanitize_text_field(wp_unslash($_GET['redirect'])) : '';
```

移除該行上方的 `// phpcs:ignore WordPress.Security.ValidatedSanitizedInput.InputNotSanitized` 註解。

**3. 修正 POST redirect 參數的 sanitize（第 152 行附近）**

目前問題：`$_POST['redirect']` 只做了 `wp_unslash()` 沒有 sanitize。
修正：加入 `sanitize_text_field()`：

```php
$redirect = isset($_POST['redirect'])
    ? sanitize_text_field(wp_unslash($_POST['redirect']))
    : '';
```

注意：`resolveRedirectUrl()` 已經在後面加了 `wp_validate_redirect`，這裡的 sanitize 是入口層的第一道防線。
  </action>
  <verify>
    <automated>php -l includes/liff/class-liff-handler.php && grep -c 'wp_validate_redirect' includes/liff/class-liff-handler.php | grep -q '[1-9]' && grep 'resolveRedirectUrl' includes/liff/class-liff-handler.php | head -5 && echo "PASS"</automated>
  </verify>
  <done>resolveRedirectUrl 使用 wp_validate_redirect 防止 Open Redirect、GET/POST redirect 參數都有 sanitize_text_field 處理</done>
</task>

<task type="auto">
  <name>Task 2: 修正 OAuth Callback 的 redirect sanitize</name>
  <files>includes/auth/class-auth-callback.php</files>
  <action>
檢查並強化 `class-auth-callback.php` 中的 redirect 處理：

**檢查 `initiateAuth()` 方法（第 95 行附近）**

目前程式碼：
```php
$redirect = isset($_GET['redirect']) ? esc_url_raw(wp_unslash($_GET['redirect'])) : '';
if (!empty($redirect)) {
    OAuthState::storeRedirect($redirect);
}
```

分析：`esc_url_raw()` 做了格式清理，`OAuthState::storeRedirect()` 內部已經用 `wp_validate_redirect()` 驗證。但入口層應該也要做 sanitize。

修正：將 `esc_url_raw` 替換為更完整的驗證流程：

```php
$redirect = isset($_GET['redirect']) ? sanitize_text_field(wp_unslash($_GET['redirect'])) : '';
if (!empty($redirect)) {
    // OAuthState::storeRedirect 內部已有 wp_validate_redirect 驗證
    OAuthState::storeRedirect($redirect);
}
```

使用 `sanitize_text_field` 而非 `esc_url_raw` 的原因：redirect 值可能是相對路徑（如 `/my-account`），`esc_url_raw` 可能會改變相對路徑的格式。`sanitize_text_field` 清理危險字元但保留路徑格式，而最終的 URL 驗證由 `OAuthState::storeRedirect` 內的 `wp_validate_redirect` 負責。

此檔案的其他 `$_GET` 使用（`$_GET['error']`、`$_GET['code']`、`$_GET['state']`）已經都有 `sanitize_text_field(wp_unslash(...))`，符合安全規範。
  </action>
  <verify>
    <automated>php -l includes/auth/class-auth-callback.php && grep "sanitize_text_field" includes/auth/class-auth-callback.php | grep -q "redirect" && echo "PASS"</automated>
  </verify>
  <done>OAuth Callback 的 redirect 參數使用 sanitize_text_field 清理，配合 OAuthState::storeRedirect 的 wp_validate_redirect 雙重防護</done>
</task>

</tasks>

<verification>
1. `php -l includes/liff/class-liff-handler.php` — 語法正確
2. `php -l includes/auth/class-auth-callback.php` — 語法正確
3. `grep -rn 'wp_validate_redirect' includes/liff/class-liff-handler.php` — resolveRedirectUrl 使用 wp_validate_redirect
4. `grep -n 'esc_url_raw.*redirect' includes/liff/class-liff-handler.php` — 應無結果（已替換）
5. `grep -n "phpcs:ignore.*InputNotSanitized" includes/liff/class-liff-handler.php` — 應無結果（已移除 suppress 註解）
</verification>

<success_criteria>
- resolveRedirectUrl() 使用 wp_validate_redirect 限制重定向只到本站
- GET/POST 的 redirect 參數都有 sanitize_text_field 入口清理
- 注入 `redirect=https://evil.com` 時系統導回首頁而非跟隨跳轉
- LINE 登入流程（正常 redirect 如 `/my-account`）不受影響
</success_criteria>

<output>
完成後建立 `.planning/phases/11-安全補齊與常數統一/11-02-SUMMARY.md`
</output>
